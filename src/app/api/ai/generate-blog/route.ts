import { NextRequest, NextResponse } from 'next/server'
import { readFile } from 'fs/promises'
import { join } from 'path'

const OPENAI_API_KEY = process.env.OPENAI_API_KEY

export async function POST(request: NextRequest) {
  try {
    if (!OPENAI_API_KEY) {
      return NextResponse.json(
        { error: 'OpenAI API key not configured' },
        { status: 500 }
      )
    }

    const { prompt, knowledgeBase, includeWebSearch = true, includeImages = true } = await request.json()

    if (!prompt) {
      return NextResponse.json(
        { error: 'Prompt is required' },
        { status: 400 }
      )
    }

    // Read CLAUDE.md file for context
    let claudeContext = ''
    try {
      const claudePath = join(process.cwd(), 'CLAUDE.md')
      claudeContext = await readFile(claudePath, 'utf-8')
    } catch (err) {
      console.log('CLAUDE.md not found, proceeding without it')
    }

    // Read SEO best practices knowledge file
    let seoKnowledge = ''
    try {
      const seoPath = join(process.cwd(), 'src/lib/knowledge/seo-best-practices.md')
      seoKnowledge = await readFile(seoPath, 'utf-8')
    } catch (err) {
      console.log('SEO knowledge file not found, proceeding without it')
    }

    // Read AI writing instructions
    let writingInstructions = ''
    try {
      const instructionsPath = join(process.cwd(), 'src/lib/knowledge/ai-writing-instructions.md')
      writingInstructions = await readFile(instructionsPath, 'utf-8')
    } catch (err) {
      console.log('AI writing instructions file not found, proceeding without it')
    }

    // Perform web search if requested
    let webSearchResults = ''
    if (includeWebSearch) {
      if (!process.env.TAVILY_API_KEY) {
        webSearchResults = 'Web search disabled: TAVILY_API_KEY not configured'
      } else {
        try {
          const searchResponse = await fetch(`https://api.tavily.com/search`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${process.env.TAVILY_API_KEY}`
            },
            body: JSON.stringify({
              query: prompt,
              search_depth: 'advanced',
              max_results: 5,
              include_answer: true
            })
          })
          
          if (searchResponse.ok) {
            const searchData = await searchResponse.json()
            webSearchResults = JSON.stringify(searchData.results || [])
          } else {
            webSearchResults = 'Web search failed: API error'
          }
        } catch (err) {
          console.log('Web search failed, proceeding without it:', err)
          webSearchResults = 'Web search failed: Network error'
        }
      }
    }

    // Prepare system message with context
    let systemMessage = `You are an expert blog writer for "thehackai", a subscription platform for curated AI documents and GPTs. 

PLATFORM CONTEXT:
${claudeContext}

AI WRITING INSTRUCTIONS (FOLLOW THESE EXACTLY):
${writingInstructions}

SEO BEST PRACTICES KNOWLEDGE:
${seoKnowledge}

ADDITIONAL KNOWLEDGE BASE:
${knowledgeBase || 'No additional knowledge base provided.'}

WEB SEARCH RESULTS (LATEST INFORMATION):
${webSearchResults}

Write a high-quality blog post that:
1. Is engaging and informative
2. Targets professionals interested in AI tools and productivity
3. Is SEO-optimized with clear headings
4. Includes actionable insights
5. Maintains a professional but approachable tone
6. Is between 800-1500 words
7. Uses markdown formatting
8. Includes a compelling meta description (under 160 characters)
Return a JSON object with:
- title: Blog post title
- content: Full blog post content in markdown
- meta_description: SEO meta description
- category: Appropriate category from: Business Planning, Productivity, Communication, Automation, Marketing, Design, Development, AI Tools, Strategy
- read_time: Estimated read time in minutes

Focus on providing real value and actionable insights to readers. Use the latest web search information to ensure accuracy and relevance.`

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content: systemMessage
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.7,
        max_tokens: 4000
      })
    })

    if (!response.ok) {
      throw new Error(`OpenAI API error: ${response.status}`)
    }

    const data = await response.json()
    const aiContent = data.choices[0]?.message?.content

    if (!aiContent) {
      throw new Error('No content generated by AI')
    }

    // Try to parse the AI response as JSON
    let blogPost
    try {
      blogPost = JSON.parse(aiContent)
    } catch (parseError) {
      // If JSON parsing fails, create a structured response
      blogPost = {
        title: 'AI-Generated Blog Post',
        content: aiContent,
        meta_description: 'An AI-generated blog post about AI tools and strategies.',
        category: 'AI Tools',
        read_time: Math.ceil(aiContent.split(' ').length / 200)
      }
    }

    // Generate images based on blog content using GPT-4o
    if (includeImages) {
      try {
        // First, ask GPT-4o to analyze the blog and suggest image ideas
        const imageAnalysisResponse = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${OPENAI_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: [
              {
                role: 'system',
                content: 'You are an expert at analyzing blog content and suggesting relevant, professional images that would enhance the article. Create detailed, specific image prompts that would be perfect for the blog content.'
              },
              {
                role: 'user',
                content: `Analyze this blog post and suggest 2-3 specific image prompts that would perfectly complement the content. Make the prompts detailed and professional, suitable for a business/tech blog.

Blog Title: ${blogPost.title}
Blog Content: ${blogPost.content}

Return a JSON array of image prompt strings: ["prompt1", "prompt2", "prompt3"]`
              }
            ],
            temperature: 0.7,
            max_tokens: 500
          })
        })

        if (imageAnalysisResponse.ok) {
          const analysisData = await imageAnalysisResponse.json()
          const analysisContent = analysisData.choices[0]?.message?.content
          
          let imagePrompts = []
          try {
            imagePrompts = JSON.parse(analysisContent)
          } catch {
            // Fallback to simple prompts if JSON parsing fails
            imagePrompts = [
              `Professional illustration representing: ${blogPost.title}`,
              `Modern tech-focused graphic about: ${blogPost.category}`,
              `Clean business-style visual for: ${blogPost.meta_description}`
            ]
          }

          // Now generate images using those prompts with GPT-4o
          const imagePromises = imagePrompts.slice(0, 3).map(async (prompt: string, index: number) => {
            const imageResponse = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${OPENAI_API_KEY}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                model: 'gpt-4o',
                messages: [
                  {
                    role: 'user',
                    content: `Create a professional, high-quality image: ${prompt}. Style: Modern, clean, business-appropriate, suitable for a tech blog. If there's any text in the image, make it crystal clear and readable.`
                  }
                ],
                max_tokens: 1000
              })
            })

            if (imageResponse.ok) {
              const imageData = await imageResponse.json()
              const content = imageData.choices[0]?.message?.content
              
              // GPT-4o should return image data or URL in the response
              // This might need adjustment based on actual GPT-4o image API format
              if (content && content.includes('http')) {
                const urlMatch = content.match(/https?:\/\/[^\s]+/)
                if (urlMatch) {
                  return {
                    url: urlMatch[0],
                    prompt: prompt,
                    description: `Image ${index + 1} for blog post`
                  }
                }
              }
            }
            return null
          })

          const generatedImages = await Promise.all(imagePromises)
          blogPost.generated_images = generatedImages.filter(img => img !== null)
        }
      } catch (err) {
        console.log('GPT-4o image generation failed:', err)
        blogPost.generated_images = []
      }
    }

    return NextResponse.json(blogPost)

  } catch (error) {
    console.error('Blog generation error:', error)
    return NextResponse.json(
      { error: 'Failed to generate blog post' },
      { status: 500 }
    )
  }
}